From 7f3f913ec5bea1d94c04f8a029db659c33e56dbf Mon Sep 17 00:00:00 2001
From: Marius Vlad <mv0@users.noreply.github.com>
Date: Sun, 24 Jul 2022 21:15:54 +0300
Subject: [PATCH 1/3] Allow the embedder to run as a regular/normal application
 (#71)

* shell: Do not issue always the ready request

Rather than sending the ready request always, just do it when we've
found at least a background type of surface.

This way we can have a flutter instance as a regular application but
also as a shell client.

This is a work-around for the time being, a much more suitable approach
would be to have a mechanism that tells us when the client has finished
loading or has it's first frame swapped (or something similar to that).

Note that we need at least a background surface so not finding one
assumes that we're a regular application (WINDOW_NORMAL).

Signed-off-by: Marius Vlad <marius.vlad@collabora.com>

* shell: Do not attempt always bind to agl-shell interface

This helps up running as a regular application in
situations where we already have a client bound to the agl-shell
interface.

We can't really accept more than one client to bind to the interface and
without a change in the protocol to avoid racy situations, it seems more
natural for the embedder to infer if it actually needs to do that.

When the protocol has been updated to include additional events to let
clients that they've lost the race, we can remove this change.

Signed-off-by: Marius Vlad <marius.vlad@collabora.com>

Co-authored-by: Marius Vlad <marius.vlad@collabora.com>
---
 shell/app.cc             | 13 +++++++++++--
 shell/wayland/display.cc | 18 +++++++++++++++---
 shell/wayland/display.h  |  8 +++++++-
 shell/wayland/window.h   |  2 +-
 4 files changed, 34 insertions(+), 7 deletions(-)

diff --git a/shell/app.cc b/shell/app.cc
index 03c33ff..3ca183b 100644
--- a/shell/app.cc
+++ b/shell/app.cc
@@ -25,8 +25,10 @@
 
 App::App(const std::vector<Configuration::Config>& configs)
     : m_wayland_display(std::make_shared<Display>(!configs[0].disable_cursor,
-                                                  configs[0].cursor_theme)) {
+                                                  configs[0].cursor_theme,
+                                                  configs)) {
   FML_DLOG(INFO) << "+App::App";
+  bool found_view_with_bg = false;
 
   size_t index = 0;
   m_views.reserve(configs.size());
@@ -35,9 +37,16 @@ App::App(const std::vector<Configuration::Config>& configs)
     view->Initialize();
     m_views.emplace_back(std::move(view));
     index++;
+
+    if (WaylandWindow::get_window_type(cfg.view.window_type) ==
+        WaylandWindow::WINDOW_BG)
+      found_view_with_bg = true;
   }
 
-  m_wayland_display->AglShellDoReady();
+  // check that if we had a BG type and issue a ready() request for it,
+  // otherwise we're going to assume that this is a NORMAL/REGULAR application.
+  if (found_view_with_bg)
+    m_wayland_display->AglShellDoReady();
 
   FML_DLOG(INFO) << "-App::App";
 }
diff --git a/shell/wayland/display.cc b/shell/wayland/display.cc
index 06eba8c..5d78471 100644
--- a/shell/wayland/display.cc
+++ b/shell/wayland/display.cc
@@ -27,7 +27,9 @@
 #include "constants.h"
 #include "engine.h"
 
-Display::Display(bool enable_cursor, std::string cursor_theme_name)
+Display::Display(bool enable_cursor,
+                 std::string cursor_theme_name,
+                 const std::vector<Configuration::Config>& configs)
     : m_xkb_context(xkb_context_new(XKB_CONTEXT_NO_FLAGS)),
       m_buffer_scale(1),
       m_last_buffer_scale(m_buffer_scale),
@@ -35,6 +37,15 @@ Display::Display(bool enable_cursor, std::string cursor_theme_name)
       m_cursor_theme_name(std::move(cursor_theme_name)) {
   FML_DLOG(INFO) << "+ Display()";
 
+  for (auto const& cfg : configs) {
+    // check if we actually need to bind to agl-shell
+    auto window_type = WaylandWindow::get_window_type(cfg.view.window_type);
+    if (window_type != WaylandWindow::WINDOW_NORMAL) {
+      m_bind_to_agl_shell = true;
+      break;
+    }
+  }
+
   m_display = wl_display_connect(nullptr);
   if (m_display == nullptr) {
     FML_LOG(ERROR) << "Failed to connect to Wayland display. "
@@ -46,7 +57,7 @@ Display::Display(bool enable_cursor, std::string cursor_theme_name)
   wl_registry_add_listener(m_registry, &registry_listener, this);
   wl_display_dispatch(m_display);
 
-  if (!m_agl_shell) {
+  if (!m_agl_shell && m_bind_to_agl_shell) {
     FML_LOG(INFO) << "agl_shell extension not present";
   }
 
@@ -152,7 +163,8 @@ void Display::registry_handle_global(void* data,
         wl_registry_bind(registry, name, &wl_seat_interface,
                          std::min(static_cast<uint32_t>(5), version)));
     wl_seat_add_listener(d->m_seat, &seat_listener, d);
-  } else if (strcmp(interface, agl_shell_interface.name) == 0) {
+  } else if (strcmp(interface, agl_shell_interface.name) == 0 &&
+             d->m_bind_to_agl_shell) {
     d->m_agl_shell = static_cast<struct agl_shell*>(
         wl_registry_bind(registry, name, &agl_shell_interface,
                          std::min(static_cast<uint32_t>(1), version)));
diff --git a/shell/wayland/display.h b/shell/wayland/display.h
index af3d460..bf05b27 100644
--- a/shell/wayland/display.h
+++ b/shell/wayland/display.h
@@ -32,11 +32,15 @@
 #include "static_plugins/text_input/text_input.h"
 #include "xdg-shell-client-protocol.h"
 
+#include "configuration/configuration.h"
+
 class Engine;
 
 class Display {
  public:
-  explicit Display(bool enable_cursor, std::string cursor_theme_name);
+  explicit Display(bool enable_cursor,
+                   std::string cursor_theme_name,
+                   const std::vector<Configuration::Config>& configs);
 
   ~Display();
 
@@ -96,6 +100,8 @@ class Display {
   struct wl_shm* m_shm{};
   struct wl_surface* m_base_surface{};
 
+  bool m_bind_to_agl_shell = false;
+
   std::map<wl_surface*, Engine*> m_surface_engine_map;
   wl_surface* m_active_surface{};
   Engine* m_active_engine{};
diff --git a/shell/wayland/window.h b/shell/wayland/window.h
index c4fe5e6..4b5c726 100644
--- a/shell/wayland/window.h
+++ b/shell/wayland/window.h
@@ -79,6 +79,7 @@ class WaylandWindow {
   wl_surface* GetBaseSurface() { return m_base_surface; }
 
   uint32_t m_fps_counter;
+  static window_type get_window_type(const std::string& type);
 
  private:
   struct shm_buffer {
@@ -157,5 +158,4 @@ class WaylandWindow {
 
   static const struct wl_callback_listener frame_listener;
 
-  static window_type get_window_type(const std::string& type);
 };
-- 
2.35.3

